# -*- coding: utf-8 -*-
"""DeepSeekDataset_0.3.0_use_division.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aFQXxJp3_Xr26Bgp3G-dizYmWupNmMRW

DeepSeekDataset_0.3.0  use_division追加
"""

import re
import random
import torch
from torch.utils.data import Dataset, DataLoader

#@title DeepSeekDataset
class DeepSeekDataset(Dataset):
    def __init__(self, tokenizer, corpus, window_size):
        self.window_size = window_size
        self.vocab_size = tokenizer.vocab_size
        self.word2index = tokenizer.word2index
        self.index2word = tokenizer.index2word
        self.tokenized_corpora = self._create_tokenized_corpora(corpus)
        self.tokenizer = tokenizer

    def __len__(self):
        return len(self.tokenized_corpora)

    def __getitem__(self, idx):
        tokenized_corpus = self.tokenized_corpora[idx]
        source = tokenized_corpus[:self.window_size]
        target = tokenized_corpus[self.window_size]

        return {
            'source': torch.tensor(source),
            'target': torch.tensor(target),
        }

    def tokenize(self, corpus):
        """
        <EOS> などのタグが分割されるのでSplitで対応

        """
        # 小文字変換
        corpus = corpus.lower()
        # 数値を分割
        corpus = self.split_digits(corpus)
        # 特殊文字の補正
        corpus = corpus.replace('< eos >', '<eos>')
        corpus = corpus.replace('< pad >', '<pad>')

        return corpus.split() # R1 <EOS> が分割されないように修正

    def _create_tokenized_corpora(self, corpus):
        tokenized_corpora = []
        tokenized_corpus = self._create_tokenized_corpus(corpus)
        tokenized_line = []
        sequence_size = self.window_size + 1

        for i in range(len(tokenized_corpus) - sequence_size):
            tokenized_sequence = tokenized_corpus[i:i + sequence_size] #['は', '晴れ', 'です']
            tokenized_corpora.append(tokenized_sequence)

        return tokenized_corpora

    def split_digits(self, text):
        # 数字部分を1桁ずつスペース区切りに変換
        return re.sub(r'\d+', lambda m: ' '.join(m.group()), text)

    def _create_tokenized_corpus(self, corpus):
        corpus = self.tokenize(corpus)
        tokenized_corpus = []

        for word in corpus:

            if word in self.word2index:
                index = self.word2index[word]
            else:
                index = self.word2index['<unk>'] # 未登録の単語として処理

            tokenized_corpus.append(index)

        return tokenized_corpus

# @title ArithmeticDataset データセットクラス
class ArithmeticDataset(Dataset):
    def __init__(self, tokenizer, context_size=20, dataset_size=1000, use_division=True):
        self.tokenizer = tokenizer
        self.context_size = context_size
        self.dataset_size = dataset_size
        self.pad_token_id = tokenizer.word2index["<pad>"]
        self.eos_token = "<eos>"
        self.eos_token_id = tokenizer.word2index[self.eos_token]
        self.use_division = use_division

        self.data = self._generate_data()

    def _generate_data(self):
        samples = []

        for _ in range(self.dataset_size):
            # 計算式とその結果を生成
            expression, result = generate_expression(self.use_division)
            sequence = expression + result + f" {self.eos_token}"
            token_ids = self.tokenizer.encode(sequence)

            # トークン列が長すぎる場合はスキップ
            if len(token_ids) > self.context_size:
                continue

            # ランダムなオフセット位置を選択
            offset = random.randint(0, self.context_size - len(token_ids))

            # context_size長のパディング付きテンソルを作成
            padded_token_ids = [self.pad_token_id] * self.context_size
            padded_token_ids[offset:offset + len(token_ids)] = token_ids

            samples.append(torch.tensor(padded_token_ids, dtype=torch.long))

        return samples

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        return self.data[idx]

# @title generate_expression関数
def generate_expression(use_division=True):
    if use_division:
        operator_choice = random.choice(['+', '-', '*', '/'])
    else:
        operator_choice = random.choice(['+', '-', '*' ])
    result = 999

    while result >= 100 or result <= -100:
        num1 = random.randint(0, 99)
        num2 = random.randint(0, 99)

        if operator_choice == '+':
            result = num1 + num2
        elif operator_choice == '-':
            result = num1 - num2
        elif operator_choice == '*':
            result = num1 * num2
        elif operator_choice == '/':
            try:
                result = num1 // num2
            except ZeroDivisionError:
                continue

            # num1 = num1 * num2
            # if num1 > 100:
            #     continue
            # try:
            #     result = num1 // num2
            # except ZeroDivisionError:
            #     continue

    result = str(result).replace('-', '- ')
    expression = f"{num1} {operator_choice} {num2} = "
    return expression, result

